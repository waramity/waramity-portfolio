crypto!!!

<div id="vm">
  <div :class="[status === 0 ? 'red' : 'green']" class="status mx-3"></div>
  <div class="clock">{*digitalClock*}</div>
  <Transition>
    <div
      v-if="!tickers[ticker]"
      class="flex flex-grow justify-center absolute w-full"
    >
      <span class="animate-pulse">
        {*statusMsg*}
      </span>
    </div>
  </Transition>

  <Transition>
    <div
      v-if="tickers[ticker]"
      class="flex gap-2 flex-grow items-center justify-between delay-200"
    >
      kuy
      <div class="w-1/2">
        <div class="flex gap-2">
          <small>{*tickers[ticker]['pair']*}</small>
          <span :class="tickers[ticker]['style']">
            <span class="mr-1">{*tickers[ticker]['arrow']*}</span>
            <span>{*tickers[ticker]['percent']*}%</span>
          </span>
        </div>
        <div>
          <span :class="tickers[ticker]['style']"
            >{*parseNumber(tickers[ticker]['close'],
            tickers[ticker]['asset'])*}</span
          >
        </div>
      </div>
    </div>
  </Transition>
</div>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"
  integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA=="
  crossorigin="anonymous"
></script>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script type="text/javascript">
  // var socket = io();

  const socket = io("/crypto");

  socket.on("connect", () => {
    console.log("Connected to server");
    setInterval(() => {
      // socket.emit('my_event', {data: 'I\'m connected!'});
      // socket.emit("ping");

      // socket.emit("connect");
      socket.emit("my_ping");
      console.log("kuy");
    }, 1000); // Send a ping every second
  });

  // socket.on("my_response", function (msg, cb) {
  //   console.log("sis");
  // });

  // socket.on("pong", () => {
  //   console.log("Received pong from server");
  // });
  // socket.on("ping", (payload) => {
  //   console.log("ping");
  //   console.log(payload);
  // });
</script>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script type="text/javascript">
  const apiEndpoint = `/en/crypto/`;
  const SCRIPT_ID = "tradingview-widget-script";
  const CONTAINER_ID = "vue-trading-view";

  const vm = new Vue({
    el: "#vm",
    delimiters: ["{*", "*}"],
    data: {
      sock: null,
      status: 0,
      tickers: {},
      cache: [],
      trades: [],
      interval: "1d",
      digitalClock: null,
      asks: [],
      bids: [],
      maxAsk: 0,
      bgImageUrl: null,
      showSettings: false,
      showLatestTrades: true,
      inputSearch: "",
      asset: "USDT",
      sort: "assetVolume",
      order: "desc",
      //chart
      ticker: "BTCUSDT",
      container_id: CONTAINER_ID,
      change: "change",
      options: {
        autosize: true,
        symbol: "BINANCE:BTCUSDT",
        interval: "5",
        timezone: "Asia/Jerusalem",
        theme: "dark",
        style: "1",
        locale: "en",
        toolbar_bg: "#f1f3f6",
        enable_publishing: false,
        withdateranges: true,
        hide_side_toolbar: false,
        allow_symbol_change: true,
        save_image: true,
        // watchlist: [
        //   'BITMEX:XBTUSD.P',
        //   'BINANCE:XMRBTC',
        // ],
        details: false,
        hotlist: false,
        studies: [
          // 'IchimokuCloud@tv-basicstudies',
          {
            id: "VWAP@tv-basicstudies",
          },
          {
            id: "MAExp@tv-basicstudies",
            inputs: {
              length: 200,
            },
            styles: {},
          },
        ],
      },
    },
    created: async function () {
      const gResponse = await fetch(apiEndpoint + "greeting");
      const gObject = await gResponse.json();
      this.flaskGreeting = gObject.greeting;
    },
    methods: {
      startClock() {
        this.digitalClock = new Date(Date.now()).toLocaleTimeString("en-GB");
        setTimeout(() => {
          this.startClock();
        }, 250);
      },
      sockInit() {
        if (this.status > 0) return;
        try {
          this.status = 0;

          this.sock = new WebSocket(
            "wss://stream.binance.com:9443/ws/!ticker@arr"
          );
          this.sock.addEventListener("open", this.onSockOpen);
          this.sock.addEventListener("close", this.onSockClose);
          this.sock.addEventListener("error", this.onSockError);
          this.sock.addEventListener("message", this.onSockData);
        } catch (err) {
          console.error("WebSocketError:", err.message || err);
          this.status = -1; // error
          this.sock = null;
        }
      },
      onSockData(e) {
        let list = JSON.parse(e.data) || [];
        if (list["error"]) {
          console.error(e);
        }
        if (list.id > 0) {
          return;
        }

        if (list.e === "aggTrade") {
          this.trades.unshift([list.E, list.p, list.q, list.m]);
          if (this.trades.length >= 200) {
            this.trades = this.trades.slice(0, 150);
          }
          return;
        }
        if (list.e === "depthUpdate") {
          // this.asks = list.a;
          // this.bids = list.b;
        }

        if (list.e === undefined) {
          for (let item of list) {
            let coin = this.getCoinData(item);
            this.tickers[coin.symbol] = coin;
            if (coin.symbol === this.ticker) {
              this.status = 2;
            }
          }
          this.cache = Object.keys(this.tickers).map((s) => this.tickers[s]);
        }
      },
      onSockOpen() {
        this.status = 1; // open
        console.info("WebSocketInfo:", "Connection open.");
        this.subscribeTicker();
      },
      onSockError(err) {
        this.status = 0; // error
        console.error("WebSocketError:", err.message || err);
        setTimeout(() => {
          this.sockInit();
        }, 10000); // try again
      },
      onSockClose() {
        this.status = 0; // closed
        console.info("WebSocketInfo:", "Connection closed.");
        setTimeout(() => {
          this.sockInit();
        }, 10000); // try again
      },
      sockClose() {
        if (this.sock) {
          this.sock.close();
        }
      },
      getCoinData(item) {
        let reg = /^([A-Z]+)(BTC|ETH|BNB|USDT|TUSD)$/;
        let symbol = String(item.s)
          .replace(/[^\w\-]+/g, "")
          .toUpperCase();
        let token = symbol.replace(reg, "$1");
        let asset = symbol.replace(reg, "$2");
        let name = token;
        let pair = token + "/" + asset;
        let icon = "/" + token.toLowerCase() + "_.png";
        let open = parseFloat(item.o);
        let high = parseFloat(item.h);
        let low = parseFloat(item.l);
        let close = parseFloat(item.c);
        let change = parseFloat(item.p);
        let percent = parseFloat(item.P);
        let trades = parseInt(item.n);
        let tokenVolume = Math.round(item.v);
        let assetVolume = Math.round(item.q);
        let sign = percent >= 0 ? "+" : "";
        let arrow = percent >= 0 ? "▲" : "▼";
        let info = [
          pair,
          close.toFixed(8),
          "(",
          arrow,
          sign + percent.toFixed(2) + "%",
          "|",
          sign + change.toFixed(8),
          ")",
        ].join(" ");
        let style = "";

        if (percent > 0) style = "green";
        if (percent < 0) style = "red";

        return {
          symbol,
          token,
          asset,
          name,
          pair,
          icon,
          open,
          high,
          low,
          close,
          change,
          percent,
          trades,
          tokenVolume,
          assetVolume,
          sign,
          arrow,
          style,
          info,
        };
      },
      subscribeTicker() {
        let streams = {
          method: "SUBSCRIBE",
          params: [
            this.ticker.toLowerCase() + "@aggTrade",
            this.ticker.toLowerCase() + "@depth",
            // this.ticker.toLowerCase() + "@kline_"+this.interval
          ],
          id: 1,
        };

        this.sock.send(JSON.stringify(streams));
      },
      parseNumber(number, currency = "") {
        // const formatters = {
        //     default: new Intl.NumberFormat(),
        //     currency: new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 }),
        //     whole: new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 0, maximumFractionDigits: 0 }),
        //     oneDecimal: new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 1, maximumFractionDigits: 1 }),
        //     twoDecimal: new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 2, maximumFractionDigits: 2 })
        // };
        if (currency.includes(["USDT"])) {
          return new Intl.NumberFormat("en-US", {
            style: "currency",
            currency: "USD",
            trailingZeroDisplay: "stripIfInteger",
          }).format(number);
        }
        return new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 10,
          trailingZeroDisplay: "stripIfInteger",
        }).format(number);
      },
    },
    mounted() {
      this.sockInit();
      this.startClock();
      // this.appendScript(this.initWidget);
      // this.prepareOrderBook();
    },
    unmounted() {
      this.sockClose();
    },
    computed: {
      statusMsg() {
        let msg = "";
        if (this.status == 0) {
          msg = "Connecting...";
        }
        if (this.status == 1) {
          msg = "Loading...";
        }
        if (this.status == 2) {
          msg = "Done";
        }
        return msg;
      },
      latestTrades() {
        if (!this.showLatestTrades) {
          return;
        }
        return this.trades;
      },
      filterTickers() {
        let tickers = this.cache;
        // filter by search
        tickers = this.cache.filter((x) =>
          x.symbol.startsWith(this.inputSearch.toUpperCase())
        );
        // filter by asset
        tickers = tickers.filter((i) => i.asset === this.asset);
        // sort
        tickers = this.quickSort(tickers, this.sort, this.order);

        return tickers;
      },
    },
  });
</script>
