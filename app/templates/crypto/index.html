crypto!!!

<div id="vm">
  <div :class="[status === 0 ? 'red' : 'green']" class="status mx-3"></div>
  <div class="clock">{*digitalClock*}</div>
  <Transition>
    <div
      v-if="!tickers[ticker]"
      class="flex flex-grow justify-center absolute w-full"
    >
      <span class="animate-pulse">
        {*statusMsg*}
      </span>
    </div>
  </Transition>

  <Transition>
    <div
      v-if="tickers[ticker]"
      class="flex gap-2 flex-grow items-center justify-between delay-200"
    >
      <small>{*tickers[ticker]['pair']*}</small>
      <span :class="tickers[ticker]['style']">
        <span class="mr-1">{*tickers[ticker]['arrow']*}</span>
        <span>{*tickers[ticker]['percent']*}%</span>
      </span>
      <span :class="tickers[ticker]['style']"
        >{*parseNumber(tickers[ticker]['close'],
        tickers[ticker]['asset'])*}</span
      >
      <small class="block">24H Highest</small>
      <span
        >{*parseNumber(tickers[ticker]['high'],
        tickers[ticker]['asset'])*}</span
      >
      <small class="block">24H Lowest</small>
      <span
        >{*parseNumber(tickers[ticker]['low'], tickers[ticker]['asset'])*}</span
      >
      <small class="block">24H Volume</small>
      <span
        >{*parseNumber(tickers[ticker]['tokenVolume'],
        tickers[ticker]['token'])*} {*tickers[ticker]['token']*}</span
      >
      <small class="block">24H Value</small>
      <span
        >{*parseNumber(tickers[ticker]['assetVolume'],
        tickers[ticker]['asset'])*} {*tickers[ticker]['asset']*}</span
      >
    </div>
  </Transition>

  <input
    v-model="inputSearch"
    class="w-full h-10 bg-transparent focus:outline-none"
    name="query"
    placeholder="Search..."
    type="text"
  />
  <ul class="flex gap-2 justify-between h-10">
    <li
      @click="filterAsset( 'USDT' )"
      :class="[asset === 'USDT' ? 'active' : '']"
      class="cb2 flex flex-grow items-center justify-center cursor-pointer"
    >
      USDT
    </li>
    <li
      @click="filterAsset( 'BTC' )"
      :class="[asset === 'BTC' ? 'active' : '']"
      class="cb2 flex flex-grow items-center justify-center cursor-pointer"
    >
      BTC
    </li>
    <li
      @click="filterAsset( 'FAV' )"
      :class="[asset === 'FAV' ? 'active' : '']"
      class="cb2 flex flex-grow items-center justify-center cursor-pointer"
    >
      FAV
    </li>
  </ul>
  <div
    @click="sortBy( 'token', 'desc' )"
    :class="[sort === 'token' ? 'font-bold' : '']"
    class="w-1/4"
  >
    Pair
  </div>
  <div
    @click="sortBy( 'close', 'desc' )"
    :class="[sort === 'close' ? 'font-bold' : '']"
    class="w-1/4 text-end"
  >
    Price
  </div>
  <div
    @click="sortBy( 'percent', 'desc' )"
    :class="[sort === 'percent' ? 'font-bold' : '']"
    class="w-1/4 text-center"
  >
    Change
  </div>
  <div
    @click="sortBy( 'assetVolume', 'desc' )"
    :class="[sort === 'assetVolume' ? 'font-bold' : '']"
    class="w-1/4 text-end pr-4"
  >
    Volume
  </div>
  <div class="body h-[454px] relative overflow-y-scroll px-2">
    <div
      v-if="Object.keys(tickers).length < 200"
      class="h-full flex items-center justify-center"
    >
      <svg
        class="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
      >
        <circle
          class="opacity-25"
          cx="12"
          cy="12"
          r="10"
          stroke="currentColor"
          stroke-width="4"
        ></circle>
        <path
          class="opacity-75"
          fill="var(--color-primary-yellow)"
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        ></path>
      </svg>
    </div>
    <div v-else>
      <div
        @click="changeTicker(ticker.symbol)"
        v-for="ticker in filterTickers"
        :key="ticker.symbol"
        class="flex hover:bg-[#eab30840] cursor-pointer"
        style="font-family: 'Roboto Mono', monospace;"
      >
        <div class="w-1/4 dotdotdot silver">
          <!-- <img src="ticker.icon" /> -->{*ticker.pair*}
        </div>
        <div :class="ticker.style" class="w-1/4 dotdotdot text-end">
          {*ticker.close*}
        </div>
        <div :class="ticker.style" class="w-1/4 dotdotdot text-center">
          {*ticker.arrow*} {*ticker.percent.toFixed(2)*}
        </div>
        <div class="w-1/4 dotdotdot silver text-end pr-4">
          {*ticker.assetVolume*}
        </div>
      </div>
    </div>
  </div>
</div>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"
  integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA=="
  crossorigin="anonymous"
></script>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script type="text/javascript">
  // var socket = io();

  const socket = io("/crypto");

  socket.on("connect", () => {
    console.log("Connected to server");
    setInterval(() => {
      // socket.emit('my_event', {data: 'I\'m connected!'});
      // socket.emit("ping");

      // socket.emit("connect");
      socket.emit("my_ping");
      console.log("kuy");
    }, 1000); // Send a ping every second
  });

  // socket.on("my_response", function (msg, cb) {
  //   console.log("sis");
  // });

  // socket.on("pong", () => {
  //   console.log("Received pong from server");
  // });
  // socket.on("ping", (payload) => {
  //   console.log("ping");
  //   console.log(payload);
  // });
</script>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script type="text/javascript">
  const apiEndpoint = `/en/crypto/`;
  const SCRIPT_ID = "tradingview-widget-script";
  const CONTAINER_ID = "vue-trading-view";

  const vm = new Vue({
    el: "#vm",
    delimiters: ["{*", "*}"],
    data: {
      sock: null,
      status: 0,
      tickers: {},
      cache: [],
      trades: [],
      interval: "1d",
      digitalClock: null,
      asks: [],
      bids: [],
      maxAsk: 0,
      bgImageUrl: null,
      showSettings: false,
      showLatestTrades: true,
      inputSearch: "",
      asset: "USDT",
      sort: "assetVolume",
      order: "desc",
      //chart
      ticker: "BTCUSDT",
      container_id: CONTAINER_ID,
      change: "change",
      options: {
        autosize: true,
        symbol: "BINANCE:BTCUSDT",
        interval: "5",
        timezone: "Asia/Jerusalem",
        theme: "dark",
        style: "1",
        locale: "en",
        toolbar_bg: "#f1f3f6",
        enable_publishing: false,
        withdateranges: true,
        hide_side_toolbar: false,
        allow_symbol_change: true,
        save_image: true,
        // watchlist: [
        //   'BITMEX:XBTUSD.P',
        //   'BINANCE:XMRBTC',
        // ],
        details: false,
        hotlist: false,
        studies: [
          // 'IchimokuCloud@tv-basicstudies',
          {
            id: "VWAP@tv-basicstudies",
          },
          {
            id: "MAExp@tv-basicstudies",
            inputs: {
              length: 200,
            },
            styles: {},
          },
        ],
      },
    },
    created: async function () {
      const gResponse = await fetch(apiEndpoint + "greeting");
      const gObject = await gResponse.json();
      this.flaskGreeting = gObject.greeting;
    },
    methods: {
      startClock() {
        this.digitalClock = new Date(Date.now()).toLocaleTimeString("en-GB");
        setTimeout(() => {
          this.startClock();
        }, 250);
      },
      sockInit() {
        if (this.status > 0) return;
        try {
          this.status = 0;

          this.sock = new WebSocket(
            "wss://stream.binance.com:9443/ws/!ticker@arr"
          );
          this.sock.addEventListener("open", this.onSockOpen);
          this.sock.addEventListener("close", this.onSockClose);
          this.sock.addEventListener("error", this.onSockError);
          this.sock.addEventListener("message", this.onSockData);
        } catch (err) {
          console.error("WebSocketError:", err.message || err);
          this.status = -1; // error
          this.sock = null;
        }
      },
      onSockData(e) {
        let list = JSON.parse(e.data) || [];
        if (list["error"]) {
          console.error(e);
        }
        if (list.id > 0) {
          return;
        }

        if (list.e === "aggTrade") {
          this.trades.unshift([list.E, list.p, list.q, list.m]);
          if (this.trades.length >= 200) {
            this.trades = this.trades.slice(0, 150);
          }
          return;
        }
        if (list.e === "depthUpdate") {
          // this.asks = list.a;
          // this.bids = list.b;
        }

        if (list.e === undefined) {
          for (let item of list) {
            let coin = this.getCoinData(item);
            this.tickers[coin.symbol] = coin;
            if (coin.symbol === this.ticker) {
              this.status = 2;
            }
          }
          this.cache = Object.keys(this.tickers).map((s) => this.tickers[s]);
        }
      },
      onSockOpen() {
        this.status = 1; // open
        console.info("WebSocketInfo:", "Connection open.");
        this.subscribeTicker();
      },
      onSockError(err) {
        this.status = 0; // error
        console.error("WebSocketError:", err.message || err);
        setTimeout(() => {
          this.sockInit();
        }, 10000); // try again
      },
      onSockClose() {
        this.status = 0; // closed
        console.info("WebSocketInfo:", "Connection closed.");
        setTimeout(() => {
          this.sockInit();
        }, 10000); // try again
      },
      sockClose() {
        if (this.sock) {
          this.sock.close();
        }
      },
      getCoinData(item) {
        let reg = /^([A-Z]+)(BTC|ETH|BNB|USDT|TUSD)$/;
        let symbol = String(item.s)
          .replace(/[^\w\-]+/g, "")
          .toUpperCase();
        let token = symbol.replace(reg, "$1");
        let asset = symbol.replace(reg, "$2");
        let name = token;
        let pair = token + "/" + asset;
        let icon = "/" + token.toLowerCase() + "_.png";
        let open = parseFloat(item.o);
        let high = parseFloat(item.h);
        let low = parseFloat(item.l);
        let close = parseFloat(item.c);
        let change = parseFloat(item.p);
        let percent = parseFloat(item.P);
        let trades = parseInt(item.n);
        let tokenVolume = Math.round(item.v);
        let assetVolume = Math.round(item.q);
        let sign = percent >= 0 ? "+" : "";
        let arrow = percent >= 0 ? "▲" : "▼";
        let info = [
          pair,
          close.toFixed(8),
          "(",
          arrow,
          sign + percent.toFixed(2) + "%",
          "|",
          sign + change.toFixed(8),
          ")",
        ].join(" ");
        let style = "";

        if (percent > 0) style = "green";
        if (percent < 0) style = "red";

        return {
          symbol,
          token,
          asset,
          name,
          pair,
          icon,
          open,
          high,
          low,
          close,
          change,
          percent,
          trades,
          tokenVolume,
          assetVolume,
          sign,
          arrow,
          style,
          info,
        };
      },
      subscribeTicker() {
        let streams = {
          method: "SUBSCRIBE",
          params: [
            this.ticker.toLowerCase() + "@aggTrade",
            this.ticker.toLowerCase() + "@depth",
            // this.ticker.toLowerCase() + "@kline_"+this.interval
          ],
          id: 1,
        };

        this.sock.send(JSON.stringify(streams));
      },
      parseNumber(number, currency = "") {
        // const formatters = {
        //     default: new Intl.NumberFormat(),
        //     currency: new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0, maximumFractionDigits: 0 }),
        //     whole: new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 0, maximumFractionDigits: 0 }),
        //     oneDecimal: new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 1, maximumFractionDigits: 1 }),
        //     twoDecimal: new Intl.NumberFormat('en-US', { style: 'decimal', minimumFractionDigits: 2, maximumFractionDigits: 2 })
        // };
        if (currency.includes(["USDT"])) {
          return new Intl.NumberFormat("en-US", {
            style: "currency",
            currency: "USD",
            trailingZeroDisplay: "stripIfInteger",
          }).format(number);
        }
        return new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 10,
          trailingZeroDisplay: "stripIfInteger",
        }).format(number);
      },
      quickSort(arr, key, order) {
        if (arr.length <= 1) {
          return arr;
        }

        const pivotIndex = Math.floor(arr.length / 2);
        const pivot = arr[pivotIndex];
        const left = [];
        const right = [];

        for (let i = 0; i < arr.length; i++) {
          if (i === pivotIndex) {
            continue;
          }

          if (order === "asc") {
            arr[i][key] < pivot[key] ? left.push(arr[i]) : right.push(arr[i]);
          } else {
            arr[i][key] > pivot[key] ? left.push(arr[i]) : right.push(arr[i]);
          }
        }

        return [
          ...this.quickSort(left, key, order),
          pivot,
          ...this.quickSort(right, key, order),
        ];
      },
      sortBy(key, order) {
        if (this.sort !== key) {
          this.order = order || "asc";
        } else {
          this.order = this.order === "asc" ? "desc" : "asc";
        }
        this.sort = key;
      },
      filterAsset(asset) {
        this.asset = String(asset || this.asset);
      },
    },
    mounted() {
      this.sockInit();
      this.startClock();
      // this.appendScript(this.initWidget);
      // this.prepareOrderBook();
    },
    unmounted() {
      this.sockClose();
    },
    computed: {
      statusMsg() {
        let msg = "";
        if (this.status == 0) {
          msg = "Connecting...";
        }
        if (this.status == 1) {
          msg = "Loading...";
        }
        if (this.status == 2) {
          msg = "Done";
        }
        return msg;
      },
      latestTrades() {
        if (!this.showLatestTrades) {
          return;
        }
        return this.trades;
      },
      filterTickers() {
        let tickers = this.cache;
        // filter by search
        tickers = this.cache.filter((x) =>
          x.symbol.startsWith(this.inputSearch.toUpperCase())
        );
        // filter by asset
        tickers = tickers.filter((i) => i.asset === this.asset);
        // sort
        tickers = this.quickSort(tickers, this.sort, this.order);

        return tickers;
      },
    },
  });
</script>
