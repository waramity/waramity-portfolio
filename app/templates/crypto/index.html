{% extends "common/_base_crypto.html" %} {% block content %}

<div id="vm">
  <Transition>
    <div v-if="!tickers[ticker]">
      {*statusMsg*}
    </div>
  </Transition>

  <Transition>
    <div v-if="tickers[ticker]" class="grid grid-cols-7 gap-2">
      <div>{*digitalClock*}</div>
      <span :class="[status === 0 ? 'text-red-500	' : 'text-green-500']">
        Status
      </span>
      <div>
        <small>{*tickers[ticker]['pair']*}</small>
        <span :class="tickers[ticker]['style']">
          <span>{*tickers[ticker]['arrow']*}</span>
          <span>{*tickers[ticker]['percent']*}%</span>
        </span>

        <span :class="tickers[ticker]['style']"
          >{*parseNumber(tickers[ticker]['close'],
          tickers[ticker]['asset'])*}</span
        >
      </div>
      <div>
        <small>24H Highest</small>
        <span
          >{*parseNumber(tickers[ticker]['high'],
          tickers[ticker]['asset'])*}</span
        >
      </div>
      <div>
        <small>24H Lowest</small>
        <span
          >{*parseNumber(tickers[ticker]['low'],
          tickers[ticker]['asset'])*}</span
        >
      </div>
      <div>
        <small>24H Volume</small>
        <span
          >{*parseNumber(tickers[ticker]['tokenVolume'],
          tickers[ticker]['token'])*} {*tickers[ticker]['token']*}</span
        >
      </div>
      <div>
        <small>24H Value</small>
        <span
          >{*parseNumber(tickers[ticker]['assetVolume'],
          tickers[ticker]['asset'])*} {*tickers[ticker]['asset']*}</span
        >
      </div>
    </div>
  </Transition>
  <div class="grid grid-cols-3 gap-2">
    <div>
      <div class="mb-5">
        <input
          v-model="inputSearch"
          name="query"
          placeholder="Search..."
          type="text"
          class="appearance-none border rounded w-full py-2 px-3 text-gray-700 focus:outline-none"
        />
      </div>

      <ul class="grid grid-cols-3 gap-2">
        <li
          @click="filterAsset( 'USDT' )"
          :class="[asset === 'USDT' ? 'bg-blue-500' : '']"
          class="cursor-pointer py-2 px-4 md:py-1 md:px-3 rounded-md border"
        >
          USDT
        </li>
        <li
          @click="filterAsset( 'BTC' )"
          :class="[asset === 'BTC' ? 'bg-blue-500' : '']"
          class="cursor-pointer py-2 px-4 md:py-1 md:px-3 rounded-md border"
        >
          BTC
        </li>
        <li
          @click="filterAsset( 'FAV' )"
          :class="[asset === 'FAV' ? 'bg-blue-500' : '']"
          class="cursor-pointer py-2 px-4 md:py-1 md:px-3 rounded-md border"
        >
          FAV
        </li>
      </ul>

      <div class="flex gap-2">
        <div
          @click="sortBy( 'token', 'desc' )"
          class="w-1/2"
          :class="[sort === 'token' ? 'font-bold' : '']"
        >
          Pair
        </div>
        <div
          @click="sortBy( 'close', 'desc' )"
          class="w-1/2"
          :class="[sort === 'close' ? 'font-bold' : '']"
        >
          Price
        </div>
        <div
          @click="sortBy( 'percent', 'desc' )"
          class="w-1/2"
          :class="[sort === 'percent' ? 'font-bold' : '']"
        >
          Change
        </div>
        <div
          @click="sortBy( 'assetVolume', 'desc' )"
          class="w-1/2"
          :class="[sort === 'assetVolume' ? 'font-bold' : '']"
        >
          Volume
        </div>
      </div>

      <div>
        <div
          @click="changeTicker(ticker.symbol)"
          v-for="ticker in filterTickers"
          :key="ticker.symbol"
          class="hover:bg-[#eab30840] cursor-pointer"
        >
          <div class="flex gap-2">
            <div class="w-1/2">
              {*ticker.pair*}
            </div>
            <div class="w-1/2" :class="ticker.style">
              {*ticker.close*}
            </div>
            <div class="w-1/2" :class="ticker.style">
              {*ticker.arrow*} {*ticker.percent.toFixed(2)*}
            </div>
            <div class="w-1/2">
              {*ticker.assetVolume*}
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>
      <div :id="container_id"></div>
    </div>

    <div class="col-3">
      <div class="row">
        <div class="col-6">
          <div
            v-for="order in bids"
            class="flex gap-2"
            :style="`background: linear-gradient(to left, #00ff0030 0 ${(order[2] / maxAsk) * 100}%, #ffffff00 ${(order[2] / maxAsk) * 100}% 100%)`"
          >
            <div class="w-1/3">
              {*parseNumber((order[0] * order[1]), asset)*}
            </div>
            <div class="w-1/3">
              {*parseFloat((order[1]))*}
            </div>
            <div class="w-1/3">
              {*parseFloat(order[0])*}
            </div>
          </div>
        </div>
        <div class="col-6">
          <div
            v-for="order in asks"
            class="flex gap-2"
            :style="`background: linear-gradient(to right, #ff000030 0 ${(order[2] / maxAsk) * 100}%, #ffffff00 ${(order[2] / maxAsk) * 100}% 100%)`"
          >
            <div class="w-1/3 flex-1 text-left">{*parseFloat(order[0])*}</div>
            <div class="w-1/3 flex-1 text-center text-[--color-primary-silver]">
              {*parseFloat((order[1]))*}
            </div>
            <div class="w-1/3 flex-1 text-end text-[--color-primary-silver]">
              {*parseNumber((order[0] * order[1]), asset)*}
            </div>
          </div>
        </div>
      </div>
      <div class="col">
        <div class="tickers w-[500px] flex flex-col gap-4">
          <div class="w-full">
            <div class="flex justify-between items-center">
              <h2
                class="text-glow font-bold text-xl h-[50px] flex items-center"
              >
                Latest Trades
              </h2>
            </div>

            <div class="row">
              <div class="col">Time</div>
              <div class="col">Price</div>
              <div class="col">Volume</div>
            </div>

            <div style="height: 50em; overflow-x: hidden;">
              <div class="2">
                <div v-for="(trade, index) in latestTrades" class="flex">
                  <div class="row">
                    <div class="col">{*timestampToDate(trade[0])*}</div>
                    <div
                      :class="[trades[index+1] != undefined && trades[index+1][1] > trades[index][1] ? 'red' : 'green']"
                      class="col"
                    >
                      {*parseFloat(trade[1])*}
                    </div>
                    <div class="col">
                      {*parseFloat(trade[2])*}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<script
  src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"
  integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA=="
  crossorigin="anonymous"
></script>

<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script type="text/javascript">
  // var socket = io();

  const socket = io("/crypto");

  socket.on("connect", () => {
    console.log("Connected to server");
    setInterval(() => {
      // socket.emit('my_event', {data: 'I\'m connected!'});
      // socket.emit("ping");

      // socket.emit("connect");
      socket.emit("my_ping");
      // console.log("kuy");
    }, 1000); // Send a ping every second
  });

  // socket.on("my_response", function (msg, cb) {
  //   console.log("sis");
  // });

  // socket.on("pong", () => {
  //   console.log("Received pong from server");
  // });
  // socket.on("ping", (payload) => {
  //   console.log("ping");
  //   console.log(payload);
  // });
</script>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script type="text/javascript">
  const apiEndpoint = `/en/crypto/`;
  const SCRIPT_ID = "tradingview-widget-script";
  const CONTAINER_ID = "vue-trading-view";

  const vm = new Vue({
    el: "#vm",
    delimiters: ["{*", "*}"],
    data: {
      sock: null,
      status: 0,
      tickers: {},
      cache: [],
      trades: [],
      interval: "1d",
      digitalClock: null,
      asks: [],
      bids: [],
      maxAsk: 0,
      bgImageUrl: null,
      showSettings: false,
      inputSearch: "",
      asset: "USDT",
      sort: "assetVolume",
      order: "desc",
      //chart
      ticker: "BTCUSDT",
      container_id: CONTAINER_ID,
      change: "change",
      numberOfTradesToShow: 10, // Set the number of trades to show
      options: {
        autosize: true,
        symbol: "BINANCE:BTCUSDT",
        interval: "5",
        timezone: "Asia/Bangkok",
        theme: "dark",
        style: "1",
        locale: "en",
        toolbar_bg: "#f1f3f6",
        enable_publishing: false,
        withdateranges: true,
        hide_side_toolbar: false,
        allow_symbol_change: true,
        save_image: true,
        // watchlist: [
        //   'BITMEX:XBTUSD.P',
        //   'BINANCE:XMRBTC',
        // ],
        details: false,
        hotlist: false,
        studies: [
          {
            id: "VWAP@tv-basicstudies",
          },
          {
            id: "MAExp@tv-basicstudies",
            inputs: {
              length: 200,
            },
          },
        ],
      },
    },
    created: async function () {
      const gResponse = await fetch(apiEndpoint + "greeting");
      const gObject = await gResponse.json();
      this.flaskGreeting = gObject.greeting;
    },
    methods: {
      startClock() {
        this.digitalClock = new Date(Date.now()).toLocaleTimeString("en-GB");
        setTimeout(() => {
          this.startClock();
        }, 250);
      },
      sockInit() {
        if (this.status > 0) return;
        try {
          this.status = 0;

          this.sock = new WebSocket(
            "wss://stream.binance.com:9443/ws/!ticker@arr"
          );
          this.sock.addEventListener("open", this.onSockOpen);
          this.sock.addEventListener("close", this.onSockClose);
          this.sock.addEventListener("error", this.onSockError);
          this.sock.addEventListener("message", this.onSockData);
        } catch (err) {
          console.error("WebSocketError:", err.message || err);
          this.status = -1; // error
          this.sock = null;
        }
      },
      onSockData(e) {
        let list = JSON.parse(e.data) || [];
        if (list["error"]) {
          console.error(e);
        }
        if (list.id > 0) {
          return;
        }

        if (list.e === "aggTrade") {
          this.trades.unshift([list.E, list.p, list.q, list.m]);
          if (this.trades.length >= 200) {
            this.trades = this.trades.slice(0, 150);
          }
          return;
        }
        if (list.e === "depthUpdate") {
          // this.asks = list.a;
          // this.bids = list.b;
        }

        if (list.e === undefined) {
          for (let item of list) {
            let coin = this.getCoinData(item);
            this.tickers[coin.symbol] = coin;
            if (coin.symbol === this.ticker) {
              this.status = 2;
            }
          }
          this.cache = Object.keys(this.tickers).map((s) => this.tickers[s]);
        }
      },
      onSockOpen() {
        this.status = 1; // open
        console.info("WebSocketInfo:", "Connection open.");
        this.subscribeTicker();
      },
      onSockError(err) {
        this.status = 0; // error
        console.error("WebSocketError:", err.message || err);
        setTimeout(() => {
          this.sockInit();
        }, 10000); // try again
      },
      onSockClose() {
        this.status = 0; // closed
        console.info("WebSocketInfo:", "Connection closed.");
        setTimeout(() => {
          this.sockInit();
        }, 10000); // try again
      },
      sockClose() {
        if (this.sock) {
          this.sock.close();
        }
      },
      getCoinData(item) {
        let reg = /^([A-Z]+)(BTC|ETH|BNB|USDT|TUSD)$/;
        let symbol = String(item.s)
          .replace(/[^\w\-]+/g, "")
          .toUpperCase();
        let token = symbol.replace(reg, "$1");
        let asset = symbol.replace(reg, "$2");
        let name = token;
        let pair = token + "/" + asset;
        let icon = "/" + token.toLowerCase() + "_.png";
        let open = parseFloat(item.o);
        let high = parseFloat(item.h);
        let low = parseFloat(item.l);
        let close = parseFloat(item.c);
        let change = parseFloat(item.p);
        let percent = parseFloat(item.P);
        let trades = parseInt(item.n);
        let tokenVolume = Math.round(item.v);
        let assetVolume = Math.round(item.q);
        let sign = percent >= 0 ? "+" : "";
        let arrow = percent >= 0 ? "▲" : "▼";
        let info = [
          pair,
          close.toFixed(8),
          "(",
          arrow,
          sign + percent.toFixed(2) + "%",
          "|",
          sign + change.toFixed(8),
          ")",
        ].join(" ");
        let style = "";

        if (percent > 0) style = "text-green-500";
        if (percent < 0) style = "text-red-500";

        return {
          symbol,
          token,
          asset,
          name,
          pair,
          icon,
          open,
          high,
          low,
          close,
          change,
          percent,
          trades,
          tokenVolume,
          assetVolume,
          sign,
          arrow,
          style,
          info,
        };
      },
      subscribeTicker() {
        let streams = {
          method: "SUBSCRIBE",
          params: [
            this.ticker.toLowerCase() + "@aggTrade",
            this.ticker.toLowerCase() + "@depth",
          ],
          id: 1,
        };

        this.sock.send(JSON.stringify(streams));
      },
      parseNumber(number, currency = "") {
        if (currency.includes(["USDT"])) {
          return new Intl.NumberFormat("en-US", {
            style: "currency",
            currency: "USD",
            trailingZeroDisplay: "stripIfInteger",
          }).format(number);
        }
        return new Intl.NumberFormat("en-US", {
          minimumFractionDigits: 10,
          trailingZeroDisplay: "stripIfInteger",
        }).format(number);
      },
      quickSort(arr, key, order) {
        if (arr.length <= 1) {
          return arr;
        }

        const pivotIndex = Math.floor(arr.length / 2);
        const pivot = arr[pivotIndex];
        const left = [];
        const right = [];

        for (let i = 0; i < arr.length; i++) {
          if (i === pivotIndex) {
            continue;
          }

          if (order === "asc") {
            arr[i][key] < pivot[key] ? left.push(arr[i]) : right.push(arr[i]);
          } else {
            arr[i][key] > pivot[key] ? left.push(arr[i]) : right.push(arr[i]);
          }
        }

        return [
          ...this.quickSort(left, key, order),
          pivot,
          ...this.quickSort(right, key, order),
        ];
      },
      sortBy(key, order) {
        if (this.sort !== key) {
          this.order = order || "asc";
        } else {
          this.order = this.order === "asc" ? "desc" : "asc";
        }
        this.sort = key;
      },
      filterAsset(asset) {
        this.asset = String(asset || this.asset);
      },
      changeTicker(symbol) {
        this.unsubscribeTicker();
        this.ticker = symbol;
        this.setSymbol(symbol);
        this.subscribeTicker();
      },
      unsubscribeTicker() {
        this.trades = [];
        this.depth = [];
        let streams = {
          method: "UNSUBSCRIBE",
          params: [
            this.ticker.toLowerCase() + "@aggTrade",
            this.ticker.toLowerCase() + "@depth",
            // this.ticker.toLowerCase() + "@kline_"+this.interval
          ],
          id: 2,
        };
        this.sock.send(JSON.stringify(streams));
      },
      setSymbol(symbol) {
        var elIframeWidget = document.querySelectorAll(
          "iframe[id*=tradingview_]"
        )[0];

        if (!elIframeWidget || !elIframeWidget.contentWindow) {
          return;
        }

        elIframeWidget.contentWindow.postMessage(
          {
            name: "set-symbol",
            data: {
              symbol: symbol,
            },
          },
          "*"
        );
      },
      appendScript(onload) {
        if (!this.canUseDOM()) {
          onload();
          return;
        }

        if (this.scriptExists()) {
          if (typeof TradingView === "undefined") {
            this.updateOnloadListener(onload);
            return;
          }
          onload();
          return;
        }
        const script = document.createElement("script");
        script.id = SCRIPT_ID;
        script.type = "text/javascript";
        script.async = true;
        script.src = "https://s3.tradingview.com/tv.js";
        script.onload = onload;
        document.getElementsByTagName("head")[0].appendChild(script);
      },
      canUseDOM() {
        return (
          typeof window !== "undefined" &&
          window.document &&
          window.document.createElement
        );
      },
      scriptExists() {
        return this.getScriptElement() !== null;
      },
      getScriptElement() {
        return document.getElementById(SCRIPT_ID);
      },
      initWidget() {
        if (typeof TradingView === "undefined") {
          return;
        }
        const widget = new window.TradingView.widget(
          Object.assign({ container_id: this.container_id }, this.options)
        );
      },
      async prepareOrderBook() {
        await fetch(
          "https://api.binance.com/api/v3/depth?symbol=" +
            this.ticker +
            "&limit=100"
        )
          .then((response) => response.text())
          .then((data) => {
            let depth = JSON.parse(data);
            this.asks = depth.asks;
            this.bids = depth.bids;

            for (let i = 0; i < this.asks.length; i++) {
              var arr = this.asks.map((x) => {
                return Number(x[1]);
              });
              this.asks[i].push(arr.slice(0, i + 1).reduce((a, b) => a + b));
            }
            for (let i = 0; i < this.bids.length; i++) {
              var arr = this.bids.map((x) => {
                return Number(x[1]);
              });
              this.bids[i].push(arr.slice(0, i + 1).reduce((a, b) => a + b));
            }
          });

        this.maxAsk = Math.max(
          ...this.asks.map((x) => {
            return x[2];
          })
        );
        setTimeout(async () => {
          await this.prepareOrderBook();
        }, 500);
      },
      timestampToDate(timestamp) {
        var options = {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          hour12: false,
          timeZone: "Asia/Bangkok",
        };
        return new Intl.DateTimeFormat("en-GB", options).format(timestamp);
      },
    },
    mounted() {
      this.sockInit();
      this.startClock();
      this.appendScript(this.initWidget);
      this.prepareOrderBook();
    },
    unmounted() {
      this.sockClose();
    },
    computed: {
      statusMsg() {
        let msg = "";
        if (this.status == 0) {
          msg = "Connecting...";
        }
        if (this.status == 1) {
          msg = "Loading...";
        }
        if (this.status == 2) {
          msg = "Done";
        }
        return msg;
      },
      latestTrades() {
        return this.trades.slice(0, this.numberOfTradesToShow);
      },
      filterTickers() {
        let tickers = this.cache;
        // filter by search
        tickers = this.cache.filter((x) =>
          x.symbol.startsWith(this.inputSearch.toUpperCase())
        );
        // filter by asset
        tickers = tickers.filter((i) => i.asset === this.asset);
        // sort
        tickers = this.quickSort(tickers, this.sort, this.order);

        return tickers;
      },
    },
  });
</script>

<style media="screen">
  #vue-trading-view {
    height: 600px;
  }
</style>

{%endblock%}
